# DO NOT EDIT THIS FILE!
#
# This code is generated off of PyCDP modules. If you need to make
# changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
import typing

from ..context import get_connection_context, get_session_context

import cdp.heap_profiler
from cdp.heap_profiler import (
    AddHeapSnapshotChunk,
    HeapSnapshotObjectId,
    HeapStatsUpdate,
    LastSeenObjectId,
    ReportHeapSnapshotProgress,
    ResetProfiles,
    SamplingHeapProfile,
    SamplingHeapProfileNode,
    SamplingHeapProfileSample
)


async def add_inspected_heap_object(
        heap_object_id: HeapSnapshotObjectId
    ) -> None:
    '''
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    :param heap_object_id: Heap snapshot object id to be accessible by means of $x command line API.
    '''
    session = get_session_context('heap_profiler.add_inspected_heap_object')
    return await session.execute(cdp.heap_profiler.add_inspected_heap_object(heap_object_id))


async def collect_garbage() -> None:
    session = get_session_context('heap_profiler.collect_garbage')
    return await session.execute(cdp.heap_profiler.collect_garbage())


async def disable() -> None:
    session = get_session_context('heap_profiler.disable')
    return await session.execute(cdp.heap_profiler.disable())


async def enable() -> None:
    session = get_session_context('heap_profiler.enable')
    return await session.execute(cdp.heap_profiler.enable())


async def get_heap_object_id(
        object_id: cdp.runtime.RemoteObjectId
    ) -> HeapSnapshotObjectId:
    '''
    :param object_id: Identifier of the object to get heap object id for.
    :returns: Id of the heap snapshot object corresponding to the passed remote object id.
    '''
    session = get_session_context('heap_profiler.get_heap_object_id')
    return await session.execute(cdp.heap_profiler.get_heap_object_id(object_id))


async def get_object_by_heap_object_id(
        object_id: HeapSnapshotObjectId,
        object_group: typing.Optional[str] = None
    ) -> cdp.runtime.RemoteObject:
    '''
    :param object_id:
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :returns: Evaluation result.
    '''
    session = get_session_context('heap_profiler.get_object_by_heap_object_id')
    return await session.execute(cdp.heap_profiler.get_object_by_heap_object_id(object_id, object_group))


async def get_sampling_profile() -> SamplingHeapProfile:
    '''


    :returns: Return the sampling profile being collected.
    '''
    session = get_session_context('heap_profiler.get_sampling_profile')
    return await session.execute(cdp.heap_profiler.get_sampling_profile())


async def start_sampling(
        sampling_interval: typing.Optional[float] = None,
        include_objects_collected_by_major_gc: typing.Optional[bool] = None,
        include_objects_collected_by_minor_gc: typing.Optional[bool] = None
    ) -> None:
    '''
    :param sampling_interval: *(Optional)* Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
    :param include_objects_collected_by_major_gc: *(Optional)* By default, the sampling heap profiler reports only objects which are still alive when the profile is returned via getSamplingProfile or stopSampling, which is useful for determining what functions contribute the most to steady-state memory usage. This flag instructs the sampling heap profiler to also include information about objects discarded by major GC, which will show which functions cause large temporary memory usage or long GC pauses.
    :param include_objects_collected_by_minor_gc: *(Optional)* By default, the sampling heap profiler reports only objects which are still alive when the profile is returned via getSamplingProfile or stopSampling, which is useful for determining what functions contribute the most to steady-state memory usage. This flag instructs the sampling heap profiler to also include information about objects discarded by minor GC, which is useful when tuning a latency-sensitive application for minimal GC activity.
    '''
    session = get_session_context('heap_profiler.start_sampling')
    return await session.execute(cdp.heap_profiler.start_sampling(sampling_interval, include_objects_collected_by_major_gc, include_objects_collected_by_minor_gc))


async def start_tracking_heap_objects(
        track_allocations: typing.Optional[bool] = None
    ) -> None:
    '''
    :param track_allocations: *(Optional)*
    '''
    session = get_session_context('heap_profiler.start_tracking_heap_objects')
    return await session.execute(cdp.heap_profiler.start_tracking_heap_objects(track_allocations))


async def stop_sampling() -> SamplingHeapProfile:
    '''


    :returns: Recorded sampling heap profile.
    '''
    session = get_session_context('heap_profiler.stop_sampling')
    return await session.execute(cdp.heap_profiler.stop_sampling())


async def stop_tracking_heap_objects(
        report_progress: typing.Optional[bool] = None,
        treat_global_objects_as_roots: typing.Optional[bool] = None,
        capture_numeric_value: typing.Optional[bool] = None,
        expose_internals: typing.Optional[bool] = None
    ) -> None:
    '''
    :param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
    :param treat_global_objects_as_roots: **(DEPRECATED)** *(Optional)* Deprecated in favor of ```exposeInternals```.
    :param capture_numeric_value: *(Optional)* If true, numerical values are included in the snapshot
    :param expose_internals: **(EXPERIMENTAL)** *(Optional)* If true, exposes internals of the snapshot.
    '''
    session = get_session_context('heap_profiler.stop_tracking_heap_objects')
    return await session.execute(cdp.heap_profiler.stop_tracking_heap_objects(report_progress, treat_global_objects_as_roots, capture_numeric_value, expose_internals))


async def take_heap_snapshot(
        report_progress: typing.Optional[bool] = None,
        treat_global_objects_as_roots: typing.Optional[bool] = None,
        capture_numeric_value: typing.Optional[bool] = None,
        expose_internals: typing.Optional[bool] = None
    ) -> None:
    '''
    :param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
    :param treat_global_objects_as_roots: **(DEPRECATED)** *(Optional)* If true, a raw snapshot without artificial roots will be generated. Deprecated in favor of ```exposeInternals```.
    :param capture_numeric_value: *(Optional)* If true, numerical values are included in the snapshot
    :param expose_internals: **(EXPERIMENTAL)** *(Optional)* If true, exposes internals of the snapshot.
    '''
    session = get_session_context('heap_profiler.take_heap_snapshot')
    return await session.execute(cdp.heap_profiler.take_heap_snapshot(report_progress, treat_global_objects_as_roots, capture_numeric_value, expose_internals))
